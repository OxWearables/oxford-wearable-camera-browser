<html>
    <head>
      <title>Test</title>

	<script src="/static/jquery.min.js"></script>
	<script src="/static/jquery-ui.js"></script>
    <script src="/static/jstree.min.js"></script>
    <script src="/static/reload-client.js"></script>
    <link rel="stylesheet" href="/static/style.min.css" />
    <style>
    .left-sticky {
		position: absolute;
		left: 0px;
		top: 0px;
		padding-left:10px;
		overflow-y: auto !important;
		overflow-x: hidden; 
		width: 201px;
		height: 100%;
		z-index:10;
		background-color: rgba(247, 245, 232, 0.9);;
    	padding-right: 1px;
	    box-sizing: border-box;
	    margin: 0px;
	}
	.left-sticky.fix-search {
	    position: fixed;
	    top: 0px;
	    height: 100%;
	  }
	  .background_text {
	  	color: #999;
	  }
	  .right-sticky {
	  	float:left; margin-left: 201px; /* 201 so we can easily find references */
	  	overflow-x:hidden;
	  	overflow-y: auto !important;
	  	height: 100%;
	  }

	  .img {
	  	margin: 0px;
	  	float: left;
	  	width: 110px;
	  	height: 190px;
	  	text-align:center;
	  	position:relative;
	  }
	  .img :after {
	  	content: '';
	      display: block;
	      clear: both;
	  }
	  .img.selected {
	  	background-color: lightcyan;
	  	-webkit-transition: background-color 0.3s;
	  	transition: background-color 0.3s;
	  }
	  img.thumbnail {
	  	cursor:pointer;
	  }

	  .split {
	  	fill-opacity:0;
	  	z-index:10;
	  	/*background-color: yellow;*/
	  	height:30px;
	  	top:0px;
	  	position:absolute;
	  }
      .split.left {
      	cursor:col-resize;
      	width: 18px;
      	left:0px;
  	  }
      .split.right {
      	cursor:col-resize;
      	width: 18px;
      	left:92px
      }
      .split.between {
      	cursor:pointer;
      	left:18px;
      	width: 73px;
      }

      .circle {
      	stroke: lightblue;
      	stroke-width:5;
      	fill:white;
      	cursor: grab;
      	cursor: -webkit-grab;
      }
	</style>
</head>
<body>
<div class="left-sticky">
	<!-- new jsonified jstree: -->
	<div id="jstree_box"  style="display:none;">
		<button type="button" id="jstree-selector" style="
	background-repeat: no-repeat;background: url(/static/cog.png); 
	width:27px; height:27px;padding:4px; border-radius:4px; border:1px solid silver; margin-top:10px;  
	position: absolute;
	top: 0;
	left: 10;" >
	    </button>
		<input type="text" id="jstree_searchbox" style="padding:4px; border-radius:4px; border:1px solid silver; margin-top:46px;">
		<div id="jstree">
		</div>
	</div>
</div>
	<script>

	var highlight_enabled = false;
function byte2Hex(n)
{
	var nybHexString = "0123456789ABCDEF";
	return String(nybHexString.substr((n >> 4) & 0x0F,1)) + nybHexString.substr(n & 0x0F,1);
}
function RGB2Color(r,g,b)
  {
    return '#' + byte2Hex(r) + byte2Hex(g) + byte2Hex(b);
  }
// https://krazydad.com/tutorials/makecolors.php
function makeColorGradient(frequency1, frequency2, frequency3,
	                           phase1, phase2, phase3,
	                           center, width, len)
	{
	  if (center == undefined)   center = 128;
	  if (width == undefined)    width = 127;
	  if (len == undefined)      len = 50;
	  var output = [];
	  for (var i = 0; i < len; ++i)
	  {
	     var red = Math.sin(frequency1*i + phase1) * width + center;
	     var grn = Math.sin(frequency2*i + phase2) * width + center;
	     var blu = Math.sin(frequency3*i + phase3) * width + center;
	     // var o = 0.5;
	     // red *= 
	     output.push(RGB2Color(red,grn,blu));
	  }
	   return output
	}


function get_leaves(schema) {
	if ('children' in schema) {
		var leaves = [];
		schema.children.forEach((c) => {
			leaves.push.apply(leaves, get_leaves(c))
		});
		return leaves;
	} else {
		return [schema];
	}
}
$(function () {
	$.ajax({
	  dataType: "json",
	  // url: '/annotation/annotation.csv',
  	  url: '/annotation/7-class.csv',

	  success: function(schema_json) {
	  		console.log(schema_json)

	  		// GENERATE COLORS
	  		var leaves = get_leaves(schema_json);
	  		console.log(leaves.length)
	  		var colors = makeColorGradient(.3,.3,.3,0,2,4, 230,100,leaves.length)
	  		console.log(colors)
	  		console.log(colors.length)
	  		leaves.forEach((l, index) => {
	  			// l.color = colors[index];
	  			l.li_attr = {style:"background-color:"+colors[index]+";background-image:false; width:24px; border-radius: 16px;"};
	  			l.icon = false;
	  			label_to_color[l.text] = colors[index]

	  		})

	  		console.log(leaves.slice(0,10))

			$('#jstree').on('loaded.jstree', function() {
				$('#jstree_box').show()
					
				var timeout = false;
				var background_text = "search" // to display "greyed out" search string
				$('#jstree_searchbox').keyup(function () {
					if(timeout) { clearTimeout(timeout); }
					timeout = setTimeout(function () {
						var v = $('#jstree_searchbox').val();
						$('#jstree').jstree(true).search(v);
					}, 250);
				}).focus(function(){
			  		if ($(this).val() == background_text){
			    		$(this).val('').removeClass('background_text');
					}
			 	}).blur(function(){
			  		if ($(this).val().length == 0){
			    		$(this).val(background_text).addClass('background_text');
					}
			 	}).val(background_text).addClass('background_text');


			}).jstree({
				"core" : {
					'data': schema_json.children,
					"multiple" : false,
					"animation" : 0,
					"check_callback" : true,
					"icons": true
				},
				"types": {
		            "label": {
		                "icon": "leaf"
		            }
		        },
				"plugins" : [  "unique","search", "types" /*,  "contextmenu"*/  ],
				"search" :  {
					"case_insensitive" : true,
					"show_only_matches":true
				}
				
			}).bind("select_node.jstree", function(e, node) {
				$("#jstree").jstree(true).toggle_node(node.node);
			}).bind("dblclick.jstree", function(e, node){
				$("#jstree").jstree(true).toggle_node(e.target);
			}).bind("move_node.jstree", function (e, data) {console.log("move_node",e, data)})

			// attach  dragging event
			// $("#jstree").mousedown(jstree_drag)
			// $("#jstree").on('open_node.jstree', expand_left_col);
			// $("#jstree").on('close_node.jstree', expand_left_col);
			
			// $.jstree.defaults.dnd.is_draggable = function(data) { console.log("is_draggable",data); return data[0].original.type === "label"}
			$('#jstree')
			    .on('mousedown', function (e) {
			    	console.log(e.target)
			    	// console.log($(e.target).hasClass('jstree-leaf'))
			    	if ($(e.target).hasClass('is_label')) {
				    	// console.log(e)

				    	// console.log($(this))
				        return $.vakata.dnd.start(e, { 'jstree' : true, 'obj' : $(e.target), 'nodes' : [{ id : true, text: $(e.target).text() }] }, '<div id="jstree-dnd" class="jstree-default"><i class="jstree-icon jstree-er"></i>' + $(e.target).text() + '</div>');
				    }
			    });
			
			$(document)
			    .on('dnd_move.vakata', function (e, data) {
			        var t = $(data.event.target);
		            if(t.closest('.img').length) {
		                data.helper.find('.jstree-icon').removeClass('jstree-er').addClass('jstree-ok');
		            }
		            else {
		                data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
		            }
		        
			    })
			    .on('dnd_stop.vakata', function (e, data) {
			    	console.log(data)
			        var t = $(data.event.target);
		            if(t.closest('.img').length) {
		            	img_idx = parseInt(t.closest('.img')[0].id);
		            	if (!Number.isInteger(img_idx)) {
		            		console.log("error: img_idx on drop ", img_idx, t.closest('.img')[0])
		            	}
		            	event_id = evts[img_idx]
		            	console.log("event_id", event_id)
		            	var label = $(data.data.obj[0]).text();
		            	var event_color = label_to_color[label];
		            	console.log("label:", label)

		            	if (Number.isInteger(event_id)) {
		            		evts.forEach((evt, idx) => {
		            			if (evt==event_id) {
		            				console.log
		            				evts[idx] = event_id;
			            			svg_colorize(idx, event_color)
			            			$('.img#'+idx).effect("highlight", {color:event_color}, 1000);
			            		}
		            		})
		            	}
		            	annotate_image(parseInt(t.closest('.img').attr('id')), label)
		            	console.log(data.data.obj[0])
		            }
		        
			    });
		}
	});
});
function annotate_image(i, label) {
	var e = evts[i];
	if (typeof(e)!=='number') {
		evts[i] = arr_max(evts)+1;
		labels[evts[i]] = label; // new event -> label
	} else {
		var new_e = arr_max(evts)+1;
		var changed = [];
		for (var v in evts) {
			if (evts[v] == e) {
				evts[v] = new_e;
				changed.push[v];
			}
		}
		labels[new_e] = label;
		new_color = label_to_color[label]
		changed.forEach(function(i) {
			svg_update(i)
			svg_colorize(i, new_color)
		})
	}
}
	</script>


	<div class="right-sticky">
		<div class="gallery">
		</div>
		<!-- <a class="load-next" href="#">Load more</a> -->
	</div>
	<script>
	url = window.location.href.split('/')
	var participant_name = url[url.indexOf('participant')+1]
	// console.log(typeof(window.location.href))
	// var participant_name = window.location.href.split('/').last()
	console.log("participant_name",participant_name)


	// all should be same length
	var imgs = []; 
	var evts = []; // event-id
	var evts_fake = []; // temp for dragging, evts is cloned from this on release
	var labels = {}; // event -> image label
	var label_to_color = {}; // image label
	// var img_sizes = {
	// 	thumbnail: [100, 87],
	// 	medium: [864,645],
	// 	original: [2592,1936]
	// }
	var start = 20, end=100;
	$.post('/participant/'+participant_name+'/images', {start:start, end:end})
		.done((response) => {
			console.log("done", start, end)
			var fake_event_id = 0;
			for(var i=0; i<=end-start;i++ ) {
				// console.log(response[i], i+start, date_from_filename(response[i]));
				imgs[i+start] = response[i];
				evts[i+start] = fake_event_id;
				if (i > 10 && Math.random() > 0.8) fake_event_id++;
			}

			for(var i=0; i<=end-start;i++ ) {
				create_image(i+start);
			}
		})
		.fail((response) => {console.log("post response:",response)});

	function new_img(img) {
		img.needs_update=true; // set needs_update to true
		// convert time to Date (not possible to send in JSON)
		if ("image_time" in img) img.image_time = new Date(img.image_time); 
	}
	function is_first_(idx) {
		return evts[idx]!==null && evts[idx] !== evts[idx-1];
	}
	function is_last_(idx) {
		return evts[idx]!==null && evts[idx] !== evts[idx+1];
	}
	function create_image(idx) { 
		var i = imgs[idx];
		var e = evts[idx];

		var is_first = is_first_(idx);
		var is_last = is_last_(idx);
		var time = date_from_filename(i);
		var label = 'none';
		var str = '<div class="img" id="'+idx+'" image-id="'+idx+'" event-id="'+(e===null ? "" : e) +'"'//+((i.label_id===null || i.label_id===undefined) ? '' : 'label-id="'+i.label_id+'" ');
		// str +=' is-last="'+is_last+'" is-first="'+is_first+'" first-id="' + first_id + '"  last-id="' + last_id + '">' 
		str += '">' 
	 	if ((e!==undefined && e!==null)) {			 	
			// if (!is_last) {
				 str += '<div style="left:92px;" class="split right" split-dir="right"></div>'
			// }
			// if (!is_first) {
				str += '<div style="left:0px;" class="split left" split-dir="left"></div>'
			// }
		}
		str += '<svg width="110" height="30">'

		str += '</svg>'
		str += '<img class="thumbnail" width="100" height="87" src="'+window.location.href+'thumbnail/'+i+'" >'
		str += '<p>' + time.toLocaleTimeString()+'</p></div>'
		// str += '<p>' + pad_num(image_time[3],2)+':'+ pad_num(image_time[4],2)+':'+pad_num(image_time[5],2)+'</p></div>'
		// console.log(str)
		$('.gallery').append(str);
		svg_ize($('.img#'+idx), idx, is_first, is_last);
	}

	function date_from_filename(n) {
	    // console.log(n.slice(6,9))
	    return new Date(
	        n.slice(17,21), // year
	        parseInt(n.slice(21,23))-1 , // month
	        n.slice(23,25), // day
	        n.slice(26,28), // hour
	        n.slice(28,30), // minutes
	        n.slice(30,32), // seconds
	        n.slice(6,9) // this is the photo's sequence number, used as a tiebreaker millisecond value for photos with the same timestamp 
	    ); 
	}

	/////// SVG stuff

	function svg_colorize(i, color) {
		if (color===undefined) color = fillcol;
		el = $("div.img#"+i);
		el.find(".line").css({fill:color})
		el.find(".circle").css({stroke:color})
		el.find(".seperator").css({stroke:color})
	}

	// SVG's must have their attributes set in a special way (not just insert raw html) which these methods facilitate
	var fillcol = 'lightblue';
	function makeCircle(el, visible) {
		el.append(makeSVG("circle", {"cx":55, "cy":15, "r":10, "class":"circle", "visibility": visible===false ? "": "hidden"}));
	}
	function makeLine(el, attrs, visible) {
		attrs['class'] = ( ('class' in attrs) ? attrs['class']+' ' : '' ) + 'line'
		attrs['visibility'] = visible===false ? "": "hidden";
		attrs['height'] = 5
		attrs['fill'] = fillcol
		attrs['y'] = 12.5
		attrs['z-index'] = 5
		// console.log(attrs)
		el.prepend(makeSVG("rect",attrs));
	}
	function makeSVG(tag, attrs) {
        var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (var k in attrs)
            el.setAttribute(k, attrs[k]);
        return el;
    }


    function svg_ize(el, i, is_first, is_last) {
    	// console.log(el, i)
    	var container = el.find("svg")
    	// var img = imgs[i];
    	// console.log(el,i, img[0],img[5])
    	makeCircle(container,!(evts[i] !== undefined && (is_first || is_last)))
		// console.log(i,  is_first ? "hidden":"" , is_last  ? "hidden":"", is_first, is_last)
		makeLine(container, {width:im_half, x:0, nx:0, id:i, class:'left'}, is_first)
		makeLine(container, {width:im_half, x:im_half, id:i, class:'right'}, is_last)
		el.find('p').text(evts[i])
    }	
    function svg_update(i, this_evts) {
    	
    	if (this_evts===undefined)  this_evts = evts;
    	var container = $('.img#'+i).find('svg');
    	var is_first =  this_evts[i]!==null && this_evts[i] !== this_evts[i-1];
    	var is_last =  this_evts[i]!==null && this_evts[i] !== this_evts[i+1];

		// console.log("svg_", i, this_evts[i], is_first, is_last)
		container.find('.circle').attr({visibility: !(this_evts[i] !== undefined && (is_first || is_last)) ? "hidden":"" })
		container.find('.line.left').attr({visibility: (this_evts[i]===null || this_evts[i]===undefined || is_first) ?  "hidden":""})
		container.find('.line.right').attr({visibility: (this_evts[i]===null || this_evts[i]===undefined || is_last) ?  "hidden":""})
		$('.img#'+i).find('p').text(this_evts[i] + " ")
		if (highlight_enabled) $('.img#'+i).effect("highlight", {}, 1000);
		// console.log("svg_update i",i )
		// console.trace()
    }

    function arr_max(arr) {
    	return arr.reduce(function (p, v) {
    	    return ( p > v ? p : v ); // get max value
    	});
    }
    function arr_min(arr) {
    	return arr.reduce(function (p, v) {
    	    return ( p < v ? p : v ); // get max value
    	});
    }







var temp = [];

    var is_dragging = false;
	var im_half = 55;
    var im_width_both = 110;
    // SPLIT IMAGES CODE
	$(function() {
		var start_img_id = null;
		var start_evt_id = null;
		var start_is_first = null;
		var start_is_last = null;
		var prev_hover_id = null;
		var start_dir = null;
		function hoverImg(e) {
			if (is_dragging) {
				e.preventDefault();
				var curr_img_id = parseInt($(e.target).closest("div.img")[0].id);
				if (curr_img_id==prev_hover_id) {
					return false;
				} 
				console.log('hoverImg', curr_img_id, prev_hover_id)

				// var hasChanged = false;
				var other_event = undefined;
				// var internal = false;

				// FIGURE OUT STATE FOR MOVE
				var state = "";
				if (start_dir==0) {
					other_event= start_evt_id
					state = "both"
				} else if (curr_img_id == start_img_id) {
					other_event = start_evt_id;
					state = "same"
				} else if ((curr_img_id - start_img_id)*start_dir > 0 ) {
					other_event= evts[start_img_id+Math.sign(curr_img_id - start_img_id)*-1];
					if (curr_img_id > start_img_id) state = "internal right" 
					else state = "internal left"
				} else  {
					other_event = start_evt_id;
					if (curr_img_id > start_img_id) state = "external right" 
					else state = "external left"
				} 
				console.log(state, other_event)
				prev_hover_id = curr_img_id;

				// LIMIT POSITION OF DRAG IF INTERNAL
				if (state == "internal left") curr_img_id =  Math.max(start_edge, curr_img_id)
				if (state == "internal right") curr_img_id =  Math.min(start_edge, curr_img_id)
				// GENERATE LIST OF CHANGED IMGS
				// DOM MANIPULATION IS INEFFICIENT, ONLY CHANGED WHERE TRUE IN ARRAY
				var START = Math.min(start_img_id, curr_img_id);
				var END = Math.max(start_img_id, curr_img_id);
				var changed = [];

				var evts_min = arr_min(Object.keys(evts).map(Number))
				var evts_max = arr_max(Object.keys(evts).map(Number))
				console.log("evts min max",evts_min, evts_max)
				if (state.startsWith("internal")) {
					// INTERNAL DRAGS DO NOT EFFECT THE DRAGGED IMG
					for (var i = evts_min;  i<=evts_max; i++) {
						var new_val = undefined;
						if (i >= START && i <= END) {
							if (i != curr_img_id) new_val = other_event;
							else new_val = start_evt_id;
						} else {
							new_val = evts[i];
						}
						if (evts_fake[i] !== new_val) {
							changed[i] = true;
							evts_fake[i] = new_val
						} else {
							changed[i] = false;
						}
					}
				} else {
					for (var i = evts_min;  i<=evts_max; i++) {
						var new_val = undefined;
						if (i >= START && i <= END) {
							new_val = other_event;
						} else {
							new_val = evts[i];
						}
						if (evts_fake[i] !== new_val) {
							changed[i] = true;
							evts_fake[i] = new_val
						} else {
							changed[i] = false;
						}
					}
				}
				if (changed.length == 0) {
					// console.log("no change: ", changed)
					return false; 
				}

				// FOR EACH IMG MUST REDRAW IF IT OR ANY NEIGHTBOURING IMGS ARE CHANGED
				var changed_min = arr_min(Object.keys(changed).map(Number))
				var changed_max = arr_max(Object.keys(changed).map(Number))
				console.log("changed min max", changed_min, changed_max)
				for (var i = changed_min;  i<=changed_max; i++) {
					if (changed[i-1] === true || changed[i] === true || changed[i+1] ===true) {
						svg_update(i, evts_fake)
						color = label_to_color[labels[evts_fake[i]]]
						console.log(i, color, evts_fake[i], labels[evts_fake[i]])
						svg_colorize(i, color)
					}
				}

				return false;
			}
		}

		$(document).on('mousedown', 'circle', function(e) {
			e.preventDefault()
			is_dragging = true;
			evts_fake = evts.slice(); // copy
			start_img_id = parseInt($(e.target).closest("div.img")[0].id);
			start_evt_id = evts[start_img_id]
			start_edge = null;
			start_is_first = is_first_(start_img_id);
			start_is_last = is_last_(start_img_id);

			for (var i in Object.keys(evts)) {
				if (evts[i]==start_evt_id) {
					if (start_is_first && (start_edge === null || i > start_edge)) start_edge = i;
					if (start_is_last && (start_edge === null || i < start_edge)) start_edge = i;
				}
			}

			start_dir = (start_is_first && start_is_last) ? 0 : (start_is_first ? 1 : -1) 
			console.log('start_is_first',start_is_first, 'start_is_last',start_is_last, 'start_dir',start_dir)
			console.log("start_img_id",start_img_id)
			$(document).on('mouseenter', 'div.img', hoverImg);
		}); 
		
		$(document).on('mouseup', function(e) {
			if (is_dragging) {
				e.preventDefault();
				$(document).off('mouseenter', 'div.img', hoverImg);
				console.log('mouseup')
				is_dragging = false;
				start_img_id = null;
				start_evt_id = null;
				start_is_first = null;
				start_is_last = null;
				start_dir = null;
				temp = evts_fake.slice()
				console.log('evts_fake',evts_fake)
				for (var v in evts_fake) {
					v = parseInt(v)
					if (evts[v] != evts_fake[v]) console.log(v, evts[v], evts_fake[v], typeof(v))
					evts[v] = evts_fake[v]
				}
				// evts = evts_fake.slice();
				evts_fake = null;
				console.log(evts)
			}
		})

        $(document).on('click', '.split', function(e) {
        	e.preventDefault();
        	// if (!$(e.target).hasClass("split")) return 0;
        	var me = $(e.target)
        	var image_id = parseInt(me.closest("div.img").attr("id"));
        	var event_id = evts[image_id];
        	console.log("ids:",image_id, event_id)
        	var dir = me.attr("split-dir") == "left" ? 1 : -1;
        	if (dir == -1 ) {
	        	$(".img#"+(image_id+1)).find('.split.left').remove()
	        	$(".img#"+(image_id)).find('.split.right').remove()
        	} else {
        		$(".img#"+(image_id-1)).find('.split.right').remove()
        		$(".img#"+(image_id)).find('.split.left').remove()        		
        	}
        	$(".fake.seperator").remove()


    		var new_event_id = arr_max(evts)+1;
        	var i = image_id;
    		console.log("dir:", i, dir, new_event_id);
        	var changed = [i-dir, i];
        	
        	console.log(i, evts[i], event_id)
        	while (evts[i] == event_id) {
	        	changed.push(i);
        		evts[i] = new_event_id;
        		i += dir;
        	}
        	changed.forEach(function(i) {
        		svg_update(i)
        	})
        	
        	// Event.split(dir, {{id}},event_id, image_id).then(reload_images)
        	return 0;
        }).on('mouseenter', '.split', function(e){ 
        	if (is_dragging) return 0;
        	var img = $(e.target).closest("div.img")
        	var id = img[0].id;
        	var dir = $(e.target).attr("split-dir");
        	if ((!is_first_(id) && dir=="left") || (!is_last_(id) && dir=="right")) return 0;
        	if (dir=="left") {
        		makeSeperator(img, {'x':10})
        		makeSeperator(img.prev("div.img"), {'x':im_width_both-10})
        	} 
        	if (dir=="right") {
        		makeSeperator(img, {'x':im_width_both-10})
        		makeSeperator(img.next("div.img"), {'x':10})
        	}
        }).on('mouseleave', '.split', function(e) { // hover off
        	var img = $(e.target).closest("div.img")
        	$(".fake.seperator").remove()
        });

        function makeSeperator(el, attrs) {
        	// $(el).find(".line").attr("visibility",'hidden')
        	attrs['fill'] = fillcol
        	attrs['width'] = 5
        	makeSeperatorLine(el, attrs);
        	if (attrs['x'] > im_half) attrs['x'] += 5;
        	else attrs['x'] -= 10;
        	attrs['fill'] = 'white'
        	attrs['width'] = 10
        	makeSeperatorLine(el, attrs);
        }
        	
        function makeSeperatorLine(el, attrs) {
        	attrs['class'] = 'fake seperator'
        	attrs['height'] = 20
        	attrs['y'] = 5
        	$(el).find("svg").append(makeSVG("rect",attrs));
        }
        if (0) {
        setTimeout(function() {$('.img#23').find(".split.right").click()} , 3250);
        setTimeout(function() {$('.img#23').find(".split.right").mouseenter()} , 2000);
        // // setTimeout(function() {$('.img#23').find(".split.right").mouseleave()} , 600);


        setTimeout(function() {$('.img#28').find(".split.left").mouseleave()} , 1550);
        setTimeout(function() {$('.img#28').find(".split.left").click()} , 1250);
        setTimeout(function() {$('.img#28').find(".split.left").mouseenter()} , 1200);
        // setTimeout(function() {$('.img#28').find(".split.left").mouseleave()} , 1600);
       setTimeout(function() {$('.img#20').find(".circle").mousedown()} , 150);
       setTimeout(function() {$('.img#20').mouseenter()} , 50);
       setTimeout(function() {$('.img#21').mouseenter()} , 350);
       setTimeout(function() {$('.img#22').mouseenter()} , 650);
       setTimeout(function() {$('.img#23').mouseenter()} , 1250);
       setTimeout(function() {$('.img#23').find(".circle").mouseup()} , 1850);
       // setTimeout(function() {$('.img#20').find(".circle").mousedown()} , 250);
    }
    })



	// SLIDE OUT SIDE ANNOTATION BAR
    var left_col_expanded = false;
    (function() {
	    var left_bar_width = 201;
		var expand_left_col = function() { // on
		        // var fn = function() { console.log("done")};
		        var max_width = Math.min(left_bar_width+left_col_expanded*500, $( window ).width()*0.9);
		        // console.log(left_col_expanded ? "on" : "off", max_width, $('.left-sticky')[0].scrollWidth)
		        $('.left-sticky').stop().animate({
		        	width:Math.min(max_width, Math.max(left_bar_width, $('.left-sticky')[0].scrollWidth))
		        }, {duration: 200, done: null});
		    }
		$('.left-sticky').hover(
		    function() { // on
		        // console.log('hover', is_dragging);
		        if (!is_dragging) {
			        left_col_expanded = true;
			        expand_left_col();
			    }
		    }, 
		    function() { // off
		        // console.log('hover off');
		        left_col_expanded = false;
		        expand_left_col();
		    }
		);

	})();

	</script>
</body>
</html>