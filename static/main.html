<html>
    <head>
      <title>SvenViewer</title>

	<script src="/static/lib/jquery.min.js"></script>
	<script src="/static/lib/jquery-ui.js"></script>
    <script src="/static/lib/jstree.min.js"></script>
    <script src="/static/lib/reload-client.js"></script>
    <script src="/static/photoswipe/photoswipe.min.js"></script>
    <script src="/static/photoswipe/photoswipe-ui-default.min.js"></script>
    <link rel="stylesheet" href="/static/jstree-style.min.css" />
    <link rel="stylesheet" href="/static/photoswipe/photoswipe.css" />
    <link rel="stylesheet" href="/static/photoswipe/default-skin/default-skin.css"> 
    <link rel="stylesheet" href="/static/font-awesome.css">
    <link rel="shortcut icon"href="/favicon.png" />
    <style>
    body {
    	margin: 0px;
    }
    a {text-decoration:none}
    button { cursor: pointer; }

    .left-sticky {
		position: absolute;
		left: 0px;
		top: 0px;
		padding-left:7;
		overflow-y: auto !important;
		overflow-x: hidden; 
		width: 201px;
		height: 100%;
		z-index:10;
		background-color: rgba(247, 245, 232, 0.9);;
    	padding-right: 1px;
	    box-sizing: border-box;
	    margin: 0px;
	}
	.left-sticky.fix-search {
	    position: fixed;
	    top: 0px;
	    height: 100%;
	  }

	  .right-sticky {
	  	margin-left: 201px; /* 201 so we can easily find references */
	  	height: 100%;
	  	overflow-y:hidden;
	  	overflow-x:hidden;
	  }
	  #right-sticky {
	  	/*overflow-x:hidden;*/
	  	overflow-y: auto;
	  	/*height: 100%;*/
	  }

	  .background_text {
	  	color: #999;
	  }
	  .img {
	  	margin: 0px;
	  	float: left;
	  	width: 110px;
	  	height: 190px;
	  	text-align:center;
	  	position:relative;
	  }
	  .img :after {
	  	content: '';
		display: block;
		clear: both;
	  }
	  .img.selected {
	  	background-color: lightcyan;
	  	-webkit-transition: background-color 0.3s;
	  	transition: background-color 0.3s;
	  }
	  img.thumbnail {
	  	cursor:pointer;
	  }

	  .split {
	  	fill-opacity:0;
	  	z-index:10;
	  	/*background-color: yellow;*/
	  	height:30px;
	  	top:0px;
	  	position:absolute;
	  }
      .split.left {
      	cursor:col-resize;
      	width: 18px;
      	left:0px;
  	  }
      .split.right {
      	cursor:col-resize;
      	width: 18px;
      	left:92px
      }
      .split.between {
      	cursor:pointer;
      	left:18px;
      	width: 73px;
      }

      .circle {
      	stroke: lightblue;
      	stroke-width:5;
      	fill:white;
      	cursor: grab;
      	cursor: -webkit-grab;
      }
      .menu-button {
      	width:34px; 
      	height:34px;
      	padding:4px; 
      	border-radius:4px; 
      	border:1px solid silver; 
      	margin-top:10px;  
      }
      #jstree_searchbox {
      	padding:4px; 
      	border-radius:4px; 
      	border:1px solid silver; 
      	margin-top:10;
      }

      /*photoSwipe*/
      #pswp-container {
        position: fixed;
        left: 201px;
        right: 0px;
        top: 0px;
        bottom: 190px;    
        z-index: -2;
      }
      .pswp {
        display: none;
        position: relative !important;
      }
      .pswp__caption__center {
      	text-align: center;
      	max-width: 1000px;
      }

      /*drag to resize photoswipe element*/
      #handle {
          position: absolute;
          left: 0;
          right: 0;
          bottom: -4px;
          height: 8px;
          cursor: ns-resize;
          z-index:2;
      }

      .gallery {
      	overflow-y:auto;
      }
	</style>
</head>
<body>
<div class="left-sticky">
	<div>
		<a  href="/">
			<button type="button" class="menu-button" id="btn-home" title="go back to homepage"><i class="fa fa-home fa-2x"></i> </button>
		</a> 
		<button type="button" class="menu-button" id="btn-save" title="save annotations"><i class="fa fa-floppy-o fa-2x"></i> </button>
		<button type="button" class="menu-button" id="btn-book?"><i class="fa fa-address-book fa-2x"></i> </button>
		<button type="button" class="menu-button" id="btn-download" title="download annotations as .csv"><i class="fa fa-download fa-2x"></i> </button>
		<button type="button" class="menu-button" id="btn-settings" title="settings"><i class="fa fa-cog fa-2x"></i> </button>
	</div>
	<!-- new jsonified jstree: -->
	<div id="jstree_box"  style="display:none;">
		<input type="text" id="jstree_searchbox">
		<div id="jstree">
		</div>
	</div>
</div>

<div class="right-sticky" id="right-sticky">

	<div id="pswp-container">

		<!-- Root element of PhotoSwipe. Must have class pswp. -->
		<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

		    <!-- Background of PhotoSwipe. 
		         It's a separate element as animating opacity is faster than rgba(). -->
		    <div class="pswp__bg"></div>

		    <!-- Slides wrapper with overflow:hidden. -->
		    <div class="pswp__scroll-wrap">

		        <!-- Container that holds slides. 
		            PhotoSwipe keeps only 3 of them in the DOM to save memory.
		            Don't modify these 3 pswp__item elements, data is added later on. -->
		        <div class="pswp__container"> 
		            <div class="pswp__item"></div>
		            <div class="pswp__item"></div>
		            <div class="pswp__item"></div>
		        </div>

		        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
		        <div class="pswp__ui pswp__ui--hidden">

		            <div class="pswp__top-bar">

		                <!--  Controls are self-explanatory. Order can be changed. -->

		                <div class="pswp__counter"></div>

		                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

		                <button class="pswp__button pswp__button--share" title="Share"></button>

		                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

		                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

		                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
		                <!-- element will get class pswp__preloader--active when preloader is running -->
		                <div class="pswp__preloader">
		                    <div class="pswp__preloader__icn">
		                      <div class="pswp__preloader__cut">
		                        <div class="pswp__preloader__donut"></div>
		                      </div>
		                    </div>
		                </div>
		            </div>

		            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
		                <div class="pswp__share-tooltip"></div> 
		            </div>

		            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
		            </button>

		            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
		            </button>

		            <div class="pswp__caption">
		                <div class="pswp__caption__center"></div>
		            </div>

		        </div>

		    </div>

		<div id="handle"></div> 
		</div>
	</div>

	<div class="gallery">
	</div>
</div>
	<script>
function byte2Hex(n)
{
	var nybHexString = "0123456789ABCDEF";
	return String(nybHexString.substr((n >> 4) & 0x0F,1)) + nybHexString.substr(n & 0x0F,1);
}
function RGB2Color(r,g,b)
  {
    return '#' + byte2Hex(r) + byte2Hex(g) + byte2Hex(b);
  }
// https://krazydad.com/tutorials/makecolors.php
function makeColorGradient(frequency1, frequency2, frequency3,
	                           phase1, phase2, phase3,
	                           center, width, len)
	{
	  if (center == undefined)   center = 128;
	  if (width == undefined)    width = 127;
	  if (len == undefined)      len = 50;
	  var output = [];
	  for (var i = 0; i < len; ++i)
	  {
	     var red = Math.sin(frequency1*i + phase1) * width + center;
	     var grn = Math.sin(frequency2*i + phase2) * width + center;
	     var blu = Math.sin(frequency3*i + phase3) * width + center;
	     // var o = 0.5;
	     // red *= 
	     output.push(RGB2Color(red,grn,blu));
	  }
	   return output
	}


function get_leaves(schema) {
	if ('children' in schema) {
		var leaves = [];
		schema.children.forEach((c) => {
			leaves.push.apply(leaves, get_leaves(c))
		});
		return leaves;
	} else {
		return [schema];
	}
}

var current_schema = null;
$(function () {

	load_schema('7-class.csv')
})
function load_schema(schema) {
	current_schema = null;
	$.ajax({
	  dataType: "json",
	  url: '/schema/'+schema,
	  success: function(schema_json) {
	  		current_schema = schema; // assign once done so we can save with correct filename
	  		load_annotation()
	  		// console.log(schema_json)

	  		// GENERATE COLORS
	  		var leaves = get_leaves(schema_json);
	  		// console.log(leaves.length)
	  		var colors = makeColorGradient(.3,.3,.3,0,2,4, 230,100,leaves.length)
	  		// console.log(colors)
	  		// console.log(colors.length)
	  		leaves.forEach((l, index) => {
	  			// l.color = colors[index];
	  			l.li_attr = {style:"background-color:"+colors[index]+";background-image:false; width:24px; border-radius: 16px;"};
	  			l.icon = false;
	  			label_to_color[l.text] = colors[index]

	  		})

	  		// console.log(leaves.slice(0,10))

			$('#jstree').on('loaded.jstree', function() {
				$('#jstree_box').show()
					
				var timeout = false;
				var background_text = "search" // to display "greyed out" search string
				$('#jstree_searchbox').keyup(function () {
					if(timeout) { clearTimeout(timeout); }
					timeout = setTimeout(function () {
						var v = $('#jstree_searchbox').val();
						$('#jstree').jstree(true).search(v);
					}, 250);
				}).focus(function(){
			  		if ($(this).val() == background_text){
			    		$(this).val('').removeClass('background_text');
					}
			 	}).blur(function(){
			  		if ($(this).val().length == 0){
			    		$(this).val(background_text).addClass('background_text');
					}
			 	}).val(background_text).addClass('background_text');


			}).jstree({
				"core" : {
					'data': schema_json.children,
					"multiple" : false,
					"animation" : 0,
					"check_callback" : true,
					"icons": true
				},
				"types": {
		            "label": {
		                "icon": "leaf"
		            }
		        },
				"plugins" : [  "unique","search", "types" /*,  "contextmenu"*/  ],
				"search" :  {
					"case_insensitive" : true,
					"show_only_matches":true
				}
				
			}).bind("select_node.jstree", function(e, node) {
				$("#jstree").jstree(true).toggle_node(node.node);
			}).bind("dblclick.jstree", function(e, node){
				$("#jstree").jstree(true).toggle_node(e.target);
			}).bind("move_node.jstree", function (e, data) {console.log("move_node",e, data)})

			// attach  dragging event
			// $("#jstree").mousedown(jstree_drag)
			// $("#jstree").on('open_node.jstree', expand_left_col);
			// $("#jstree").on('close_node.jstree', expand_left_col);
			
			// $.jstree.defaults.dnd.is_draggable = function(data) { console.log("is_draggable",data); return data[0].original.type === "label"}
			$('#jstree')
			    .on('mousedown', function (e) {
			    	console.log(e.target)
			    	// console.log($(e.target).hasClass('jstree-leaf'))
			    	if ($(e.target).hasClass('is_label')) {
				    	// console.log(e)

				    	// console.log($(this))
				        return $.vakata.dnd.start(e, { 'jstree' : true, 'obj' : $(e.target), 'nodes' : [{ id : true, text: $(e.target).text() }] }, '<div id="jstree-dnd" class="jstree-default"><i class="jstree-icon jstree-er"></i>' + $(e.target).text() + '</div>');
				    }
			    });
			
			$(document)
			    .on('dnd_move.vakata', function (e, data) {
			        var t = $(data.event.target);
		            if(t.closest('.img').length) {
		                data.helper.find('.jstree-icon').removeClass('jstree-er').addClass('jstree-ok');
		            }
		            else {
		                data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
		            }
		        
			    })
			    .on('dnd_stop.vakata', function (e, data) {
			    	console.log(data)
			        var t = $(data.event.target);
		            if(t.closest('.img').length) {
		            	img_idx = parseInt(t.closest('.img')[0].id);
		            	if (!Number.isInteger(img_idx)) {
		            		console.log("error: img_idx on drop ", img_idx, t.closest('.img')[0])
		            	}
		            	event_id = evts[img_idx]
		            	console.log("event_id", event_id)
		            	var label = $(data.data.obj[0]).text();
		            	var event_color = label_to_color[label];
		            	console.log("label:", label)

		            	if (Number.isInteger(event_id)) {
		            		evts.forEach((evt, idx) => {
		            			if (evt==event_id) {
		            				console.log
		            				evts[idx] = event_id;
			            			svg_colorize(idx, event_color)
			            			$('.img#'+idx).effect("highlight", {color:event_color}, 1000);
			            		}
		            		})
		            	}
		            	annotate_image(parseInt(t.closest('.img').attr('id')), label)
		            	console.log(data.data.obj[0])
		            	set_tooltip(data.event);
		            }
		        
			    });
		}
	});
}

function annotate_image(i, label) {
	var e = evts[i];
	if (typeof(e)!=='number') {
		evts[i] = arr_max(evts)+1;
		labels[evts[i]] = label; // new event -> label
	} else {
		var new_e = arr_max(evts)+1;
		var changed = [];
		for (var v in evts) {
			if (evts[v] == e) {
				evts[v] = new_e;
				changed.push[v];
			}
		}
		labels[new_e] = label;
		new_color = label_to_color[label]
		changed.forEach(function(i) {
			svg_update(i)
			svg_colorize(i, new_color)
		})
	}
}


	var url = window.location.href.split('/')
	var participant_name = url[url.indexOf('participant')+1]
	console.log("participant_name",participant_name)


	// all should be same length
	var imgs = []; 
	var img_times = []; 
	var evts = []; // event-id
	var evts_fake = null; // temp for dragging, evts is cloned from this on release
	var labels = {}; // event -> image label
	var label_to_color = {}; // image label

	var start = 0, end=200;
	$.post('/participant/'+participant_name+'/images', {start:start, end:end})
		.done((response) => {
			for(var i=0; i<=end-start;i++ ) {
				// if there are not enough images will recieve undefined values
				if (response[i]!==undefined && response[i]!==null) { 
					imgs[i+start] = response[i];
					evts[i+start] = evts[i+start] || 0;
					img_times[i+start] = date_from_filename(response[i])
				}
			}
			for(var i=0; i<=end-start;i++ ) {
				create_image(i+start);
			}

		})
		.fail((response) => {console.log("post response:",response)});


	function is_first_(idx) {
		return evts[idx]!==null && evts[idx] !== evts[idx-1];
	}
	function is_last_(idx) {
		return evts[idx]!==null && evts[idx] !== evts[idx+1];
	}
	function create_image(idx) { 
		var i = imgs[idx];
		var e = evts[idx];

		var is_first = is_first_(idx);
		var is_last = is_last_(idx);
		var time = date_from_filename(i);
		var label = 'none';
		var str = '<div class="img" id="'+idx+'" image-id="'+idx+'" event-id="'+(e===null ? "" : e) +'"'//+((i.label_id===null || i.label_id===undefined) ? '' : 'label-id="'+i.label_id+'" ');
		// str +=' is-last="'+is_last+'" is-first="'+is_first+'" first-id="' + first_id + '"  last-id="' + last_id + '">' 
		str += '">' 
	 	// if ((e!==undefined && e!==null)) {			 	
			// if (!is_last) {
				 str += '<div style="left:92px;" class="split right" split-dir="right"></div>'
			// }
			// if (!is_first) {
				str += '<div style="left:0px;" class="split left" split-dir="left"></div>'
			// }
		// }
		str += '<svg width="110" height="30">'

		str += '</svg>'
		str += '<img class="thumbnail" width="100" height="87" src="/images/'+participant_name+'/thumbnail/'+i+'" >'
		str += '<p>' + time.toLocaleTimeString()+'</p></div>'
		// str += '<p>' + pad_num(image_time[3],2)+':'+ pad_num(image_time[4],2)+':'+pad_num(image_time[5],2)+'</p></div>'
		// console.log(str)
		$('.gallery').append(str);
		svg_ize($('.img#'+idx), idx, is_first, is_last);
	}

	function date_from_filename(n) {
	    // console.log(n.slice(6,9))
	    return new Date(
	        n.slice(17,21), // year
	        parseInt(n.slice(21,23))-1 , // month
	        n.slice(23,25), // day
	        n.slice(26,28), // hour
	        n.slice(28,30), // minutes
	        n.slice(30,32), // seconds
	        n.slice(6,9) // this is the photo's sequence number, used as a tiebreaker millisecond value for photos with the same timestamp 
	    ); 
	}

	/////// SVG stuff

	function svg_colorize(i, color) {
		if (color===undefined) color = fillcol;
		el = $("div.img#"+i);
		el.find(".line").css({fill:color})
		el.find(".circle").css({stroke:color})
		el.find(".seperator").css({stroke:color})
	}

	// SVG's must have their attributes set in a special way (not just insert raw html) which these methods facilitate
	var fillcol = 'lightblue';
	function makeCircle(el, visible) {
		el.append(makeSVG("circle", {"cx":55, "cy":15, "r":10, "class":"circle", "visibility": visible===false ? "": "hidden"}));
	}
	function makeLine(el, attrs, visible) {
		attrs['class'] = ( ('class' in attrs) ? attrs['class']+' ' : '' ) + 'line'
		attrs['visibility'] = visible===false ? "": "hidden";
		attrs['height'] = 5
		attrs['fill'] = fillcol
		attrs['y'] = 12.5
		attrs['z-index'] = 5
		// console.log(attrs)
		el.prepend(makeSVG("rect",attrs));
	}
	function makeSVG(tag, attrs) {
        var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (var k in attrs)
            el.setAttribute(k, attrs[k]);
        return el;
    }


    function svg_ize(el, i, is_first, is_last) {
    	// console.log(el, i)
    	var container = el.find("svg")
    	// var img = imgs[i];
    	// console.log(el,i, img[0],img[5])
    	makeCircle(container,!(evts[i] !== undefined && (is_first || is_last)))
		// console.log(i,  is_first ? "hidden":"" , is_last  ? "hidden":"", is_first, is_last)
		makeLine(container, {width:im_half, x:0, nx:0, id:i, class:'left'}, is_first)
		makeLine(container, {width:im_half, x:im_half, id:i, class:'right'}, is_last)
		// el.find('p').text(evts[i])
    }	
    function svg_update(i, this_evts) {
    	if (typeof(i)=="string") throw Error("no string indexes!!")
    	if (this_evts===undefined)  this_evts = evts;
    	var container = $('.img#'+i).find('svg');
    	var is_first =  this_evts[i]!==null && this_evts[i] !== this_evts[i-1];
    	var is_last =  this_evts[i]!==null && this_evts[i] !== this_evts[i+1];
    	// console.log(i, is_first, is_last)
		// console.log("svg_", i, this_evts[i-1], this_evts[i], this_evts[i+1], is_first, is_last)
		container.find('.circle').attr({visibility: !(this_evts[i] !== undefined && (is_first || is_last)) ? "hidden":"" })
		container.find('.line.left').attr({visibility: (this_evts[i]===null || this_evts[i]===undefined || is_first) ?  "hidden":""})
		container.find('.line.right').attr({visibility: (this_evts[i]===null || this_evts[i]===undefined || is_last) ?  "hidden":""})
    }

    function arr_max(arr) {
    	return arr.reduce(function (p, v) {
    	    return ( p > v ? p : v ); // get max value
    	});
    }
    function arr_min(arr) {
    	return arr.reduce(function (p, v) {
    	    return ( p < v ? p : v ); // get max value
    	});
    }








    var is_dragging = false;
	var im_half = 55;
    var im_width_both = 110;
    // SPLIT IMAGES CODE
	$(function() {
		var start_img_id = null;
		var start_evt_id = null;
		var start_is_first = null;
		var start_is_last = null;
		var prev_hover_id = null;
		var start_dir = null;
		function hoverImg(e) {
			if (is_dragging) {
				set_tooltip(e);

				e.preventDefault();
				var curr_img_id = parseInt($(e.target).closest("div.img")[0].id);
				if (curr_img_id==prev_hover_id) {
					return true;
				} 
				console.log('hoverImg', curr_img_id, prev_hover_id)

				// var hasChanged = false;
				var other_event = undefined;
				// var internal = false;

				// FIGURE OUT STATE FOR MOVE
				var state = "";
				if (start_dir==0) {
					other_event= start_evt_id
					state = "both"
				} else if (curr_img_id == start_img_id) {
					other_event = start_evt_id;
					state = "same"
				} else if ((curr_img_id - start_img_id)*start_dir > 0 ) {
					other_event= evts[start_img_id+Math.sign(curr_img_id - start_img_id)*-1];
					if (curr_img_id > start_img_id) state = "internal right" 
					else state = "internal left"
				} else  {
					other_event = start_evt_id;
					if (curr_img_id > start_img_id) state = "external right" 
					else state = "external left"
				} 
				console.log(state, other_event)
				prev_hover_id = curr_img_id;

				// LIMIT POSITION OF DRAG IF INTERNAL
				if (state == "internal left") curr_img_id =  Math.max(start_edge, curr_img_id)
				if (state == "internal right") curr_img_id =  Math.min(start_edge, curr_img_id)
				// GENERATE LIST OF CHANGED IMGS
				// DOM MANIPULATION IS INEFFICIENT, ONLY CHANGED WHERE TRUE IN ARRAY
				var START = Math.min(start_img_id, curr_img_id);
				var END = Math.max(start_img_id, curr_img_id);
				var changed = [];

				var evts_min = arr_min(Object.keys(evts).map(Number))
				var evts_max = arr_max(Object.keys(evts).map(Number))
				console.log("evts min max",evts_min, evts_max)
				if (state.startsWith("internal")) {
					// INTERNAL DRAGS DO NOT EFFECT THE DRAGGED IMG
					for (var i = evts_min;  i<=evts_max; i++) {
						var new_val = undefined;
						if (i >= START && i <= END) {
							if (i != curr_img_id) new_val = other_event;
							else new_val = start_evt_id;
						} else {
							new_val = evts[i];
						}
						if (evts_fake[i] !== new_val) {
							changed[i] = true;
							evts_fake[i] = new_val
						} else {
							changed[i] = false;
						}
					}
				} else {
					for (var i = evts_min;  i<=evts_max; i++) {
						var new_val = undefined;
						if (i >= START && i <= END) {
							new_val = other_event;
						} else {
							new_val = evts[i];
						}
						if (evts_fake[i] !== new_val) {
							changed[i] = true;
							evts_fake[i] = new_val
						} else {
							changed[i] = false;
						}
					}
				}
				if (changed.length == 0) {
					// console.log("no change: ", changed)
					return true; 
				}

				// FOR EACH IMG MUST REDRAW IF IT OR ANY NEIGHTBOURING IMGS ARE CHANGED
				var changed_min = arr_min(Object.keys(changed).map(Number))
				var changed_max = arr_max(Object.keys(changed).map(Number))
				console.log("changed min max", changed_min, changed_max)
				for (var i = changed_min;  i<=changed_max; i++) {
					if (changed[i-1] === true || changed[i] === true || changed[i+1] ===true) {
						svg_update(i, evts_fake)
						color = label_to_color[labels[evts_fake[i]]]
						console.log(i, color, evts_fake[i], labels[evts_fake[i]])
						svg_colorize(i, color)
					}
				}

				return true;
			}
		}

		$(document).on('mousedown', 'circle', function(e) {
			e.preventDefault()
			is_dragging = true;
			evts_fake = evts.slice(); // copy
			start_img_id = parseInt($(e.target).closest("div.img")[0].id);
			start_evt_id = evts[start_img_id]
			start_edge = null;
			start_is_first = is_first_(start_img_id);
			start_is_last = is_last_(start_img_id);

			evts.forEach((evt, i) =>{
				if (evt==start_evt_id) {
					if (start_is_first && (start_edge === null || i > start_edge)) start_edge = i;
					if (start_is_last && (start_edge === null || i < start_edge)) start_edge = i;
				}
			}) 

			start_dir = (start_is_first && start_is_last) ? 0 : (start_is_first ? 1 : -1) 
			// console.log('start_is_first',start_is_first, 'start_is_last',start_is_last, 'start_dir',start_dir)
			// console.log("start_edge",start_edge)
			$(document).on('mouseenter', 'div.img', hoverImg);
		}); 
		
		$(document).on('mouseup', function(e) {
			if (is_dragging) {
				e.preventDefault();
				$(document).off('mouseenter', 'div.img', hoverImg);
				is_dragging = false;
				start_img_id = null;
				start_evt_id = null;
				start_is_first = null;
				start_is_last = null;
				start_dir = null;
				for (var v in evts_fake) {
					v = parseInt(v)
					if (evts[v] != evts_fake[v]) console.log(v, evts[v], evts_fake[v], typeof(v))
					evts[v] = evts_fake[v]
				}
				// evts = evts_fake.slice();
				evts_fake = null;
				console.log('mouseup')
				set_tooltip(e);
			}
		})

        $(document).on('click', '.split', function(e) {
        	// if (!$(e.target).hasClass("split")) return 0;
        	var me = $(e.target)
        	var image_id = parseInt(me.closest("div.img").attr("id"));
        	var event_id = evts[image_id];
        	// console.log("ids:",image_id, event_id)
        	var dir = me.attr("split-dir") == "left" ? 1 : -1;
        	if ((is_first_(image_id) && dir==1) || (is_last_(image_id) && dir==-1)) return 0;
        	e.preventDefault();

        	$(".fake.seperator").remove()


    		var new_event_id = arr_max(evts)+1;
        	var i = image_id;
    		// console.log("dir:", i, dir, new_event_id);
        	var changed = [i-dir, i];
        	
        	console.log(i, evts[i], event_id)
        	while (evts[i] == event_id) {
	        	changed.push(i);
        		evts[i] = new_event_id;
        		i += dir;
        	}
        	// give new event same label as old event
        	if (event_id in labels) labels[new_event_id] = labels[event_id]
        	changed.forEach(function(i) {
        		svg_update(i)
        	})
        	
        	// Event.split(dir, {{id}},event_id, image_id).then(reload_images)
        	return 0;
        }).on('mouseenter', '.split', function(e){ 
        	if (is_dragging) return true; // true allows jquery event bubbling up
        	var img = $(e.target).closest("div.img")
        	var image_id = parseInt(img.attr("id"));
        	var dir = $(e.target).attr("split-dir");
        	// console.log(image_id, ".split dir:", dir, is_first_(image_id), is_last_(image_id) )
        	if ((is_first_(image_id) && dir=="left") || (is_last_(image_id) && dir=="right")) return true;
        	// console.log(labels[evts[image_id]])
        	var color = label_to_color[labels[evts[image_id]]]
        	if (dir=="left") {
        		makeSeperator(img, {'x':10,'fill':color})
        		makeSeperator(img.prev("div.img"), {'x':im_width_both-10,'fill':color})
        	} 
        	if (dir=="right") {
        		makeSeperator(img, {'x':im_width_both-10,'fill':color})
        		makeSeperator(img.next("div.img"), {'x':10,'fill':color})
        	}
        }).on('mouseleave', '.split', function(e) { // hover off
        	var img = $(e.target).closest("div.img")
        	$(".fake.seperator").remove()
        });

        function makeSeperator(el, attrs) {
        	// $(el).find(".line").attr("visibility",'hidden')
        	if (!('fill' in attrs) || attrs['fill']===undefined) attrs['fill'] = fillcol
        	attrs['width'] = 5
        	makeSeperatorLine(el, attrs);
        	if (attrs['x'] > im_half) attrs['x'] += 5;
        	else attrs['x'] -= 10;
        	attrs['fill'] = 'white'
        	attrs['width'] = 10
        	makeSeperatorLine(el, attrs);
        }
        	
        function makeSeperatorLine(el, attrs) {
        	attrs['class'] = 'fake seperator'
        	attrs['height'] = 20
        	attrs['y'] = 5
        	$(el).find("svg").append(makeSVG("rect",attrs));
        }

    })


	// SLIDE OUT SIDE ANNOTATION BAR
    var left_col_expanded = false;
    (function() {
	    var left_bar_width = 201;
		var expand_left_col = function() { // on
		        // var fn = function() { console.log("done")};
		        var max_width = Math.min(left_bar_width+left_col_expanded*500, $( window ).width()*0.9);
		        console.log(left_col_expanded ? "on" : "off", max_width, $('.left-sticky')[0].scrollWidth)
		        console.log($('.left-sticky')[0].offsetWidth, $('.left-sticky')[0].clientWidth)
		        $('.left-sticky').stop().animate({
		        	width:Math.min(max_width, Math.max(left_bar_width, $('.left-sticky')[0].scrollWidth))
		        }, {duration: 200, done: null});
		    }
		$('.left-sticky').hover(
		    function() { // on
		        // console.log('hover', is_dragging);
		        if (!is_dragging) {
			        left_col_expanded = true;
			        expand_left_col();
			    }
		    }, 
		    function() { // off
		        // console.log('hover off');
		        left_col_expanded = false;
		        expand_left_col();
		    }
		);

		$("#jstree").on('open_node.jstree', expand_left_col);
		$("#jstree").on('close_node.jstree', expand_left_col);
	})();



	$(document).ready(function() {
		$(document).on('mouseenter', '.img', set_tooltip);
		$(document).on('mouseup', '.img', set_tooltip);


        $(document).on('mouseleave', '.img', function(e) { 
            $('.tooltip').css('display', 'none');
            $(e.target).closest('div.img')
            $(e.target).closest('div.img').find('p').show()
        });

    });
	function set_tooltip(e) {
		// console.log("tooltip")
		var image_id = parseInt($(e.target).closest('div.img').attr('id'));
		// console.log("evts_fake==null", evts_fake==null)
		if (evts_fake!==null)  label = labels[evts_fake[image_id]];
		else label = labels[evts[image_id]];
		if (!label) label = "none";
		if (typeof(image_id)=="number") {

			// var pos = $(e.target).closest('div.img')

			// var pos = $(e.target).closest('div.img').offset()
            // put other effect in when moving over the element

            // from e you can get the pageX(left position) and pageY(top position) 
            // im not sure if it was the relative or the absolute position
            // i added 10 pxs on the top and left to show the tooltip a bit after
            $('.tooltip').css('display', 'block');
			$('.tooltip').text(label).appendTo($(e.target).closest('div.img'))
			$(e.target).closest('div.img').find('p').not('.tooltip').hide()

		}
		return true
    }
	</script>
	<style>
	      .tooltip {
	              position: relative; /** depends on how it handles the e.pageX and e.pageY **/
	              width: 100;
	              /*height: 30px;*/
	              margin: 5px;
	              background: #FFF;
	              border-radius:6px;
	              border: 1px solid #000;
	              z-index: 20;
	              text-align: center;
	              display: none; /**let the tooltip be not visable, when startup **/
	              pointer-events:none;   /*css-property that makes events "pass through" an DOM-element  */
	          }
	</style>
	<div class="tooltip">Tooltip</div>
	<script>

	$(document).on('mousedown','.gallery', function(e) {
		console.log('openPhotoSwipe(idx)')
	})
	$(document).on('mousedown','.thumbnail', function(e) {
		console.log('openPhotoSwipe(idx)')
		if (e.which!==1) return; 
		var idx = parseInt($(this).closest(".img").attr("id"))
		openPhotoSwipe(idx)

	})
	var img_sizes = {
		thumbnail: [100, 87],
		medium: [864,645],
		full: [2592,1936]
	}
	    // stop loading more images when pswp is open
	    var pswpIsOpen = false;
	    var pswp;

	    // $(function() {slides = new Array(imgs.length)})
		function openPhotoSwipe(index) {
			if (pswpIsOpen) {
				pswp.goTo(index);
				return;
			}
			pswpIsOpen = true;
			$('.gallery').height(200)
			console.log(index)
			var slides = imgs.map(function(img) { 
				return {url: img}
			});
		    $(".right-sticky").removeAttr('id')
			console.log(slides)
			var pswpElement = document.querySelectorAll('.pswp')[0];
			var options = {
				shareEl: false,
				tapToClose: false,
				index: index,
				getThumbBoundsFn: function(index) {

				    // find thumbnail element
				    var thumbnail = $("div#"+index+".img").find(".thumbnail")[0];
				    // get window scroll Y
				    var pageYScroll = window.pageYOffset || document.documentElement.scrollTop; 
				    // optionally get horizontal scroll

				    // get position of element relative to viewport
				    var rect = thumbnail.getBoundingClientRect(); 

				    // w = width
				    return {x:rect.left - 201, y:rect.top + pageYScroll, w:rect.width};

				},
				history: false,
				closeOnVerticalDrag: false,
				closeOnScroll: false
				// modal: true
			}
			pswp = new PhotoSwipe( pswpElement, PhotoSwipeUI_Default, slides, options);
			// create variable that will store real size of viewport
			var realViewportWidth,
			    useLargeImages = false,
			    firstResize = true,
			    imageSrcWillChange;

			// beforeResize event fires each time size of gallery viewport updates
			pswp.listen('beforeResize', function() {
			    // calculate real pixels when size changes
			    realViewportWidth = pswp.viewportSize.x * window.devicePixelRatio;

			    // Code below is needed if you want image to switch dynamically on window.resize

			    // Find out if current images need to be changed
			    if(useLargeImages && realViewportWidth < img_sizes.medium[0]) {
			        useLargeImages = false;
			        imageSrcWillChange = true;
			    } else if(!useLargeImages && realViewportWidth >= img_sizes.medium[0]) {
			        useLargeImages = true;
			        imageSrcWillChange = true;
			    }

			    // Invalidate items only when source is changed and when it's not the first update
			    if(imageSrcWillChange && !firstResize) {
			        // invalidateCurrItems sets a flag on slides that are in DOM,
			        // which will force update of content (image) on window.resize.
			        pswp.invalidateCurrItems();
			    }

			    if(firstResize) {
			        firstResize = false;
			    }

			    imageSrcWillChange = false;

			});


			// gettingData event fires each time PhotoSwipe retrieves image source & size
			pswp.listen('gettingData', function(index, item) {
				console.log('gettingData',index, item)
			    // Set image source & size based on real viewport width
			    if( useLargeImages ) {
			        item.src = '/images/'+participant_name+'/full/'+imgs[index];
			        item.w = img_sizes.full[0],
			        item.h = img_sizes.full[1]
			    } else {
			        item.src = '/images/'+participant_name+'/medium/'+imgs[index];
			        item.w = img_sizes.medium[0],
			        item.h = img_sizes.medium[1]
			    }
		        item.msrc = '/images/'+participant_name+'/thumbnail/'+imgs[index];
			    item.title = labels[evts[index]] || ""
			    // if (labels[evts[index]]) item.title = labels[imgs[index].label_id].text
			    // else console.log("no img text for ", index, imgs[index])
			});

			var scrollTargetPos = null;
			// pswp.listen('beforeChange', function() {
			// 	var img = pswp.currItem;
			// 	if (img.label_id!=null) img.title = labels[img.label_id].text
			// });

			pswp.listen('afterChange', function() {

		    	var index = pswp.getCurrentIndex()

		    	// http://stackoverflow.com/questions/2905867/how-to-scroll-to-specific-item-using-jquery
		    	var container = $('.gallery'),
		    	    scrollTo = $("div#"+index+".img");
		    	
		    	// container.scrollTop(
		    	//     scrollTargetPos
		    	// );

		    	// Or you can animate the scrolling:
		    	if (scrollTo.offset().top - container.offset().top + container.scrollTop()!=scrollTargetPos) {
			    	scrollTargetPos = scrollTo.offset().top - container.offset().top + container.scrollTop();
			    	container.stop().animate({
			    	    scrollTop: scrollTargetPos
			    	})
		    	}
		    	// var bgcol = scrollTo.css("background-color")
		    	scrollTo.stop(undefined, true)
		    	scrollTo.effect('highlight',{color:'lightblue'}, 1000)
		    })
		    // store the original scroll postion
		    var originalScroll = $(window).scrollTop();

		    $("#pswp-container").css('z-index',2);
		    
		    setCorrectHeight();

		    $(pswpElement).show();


		    pswp.listen('close', function(){
				
			    $(".gallery").css({
			    	marginTop: '', 
			    	height: '',
			    	overflowY: ''
		    	})



			    var index = pswp.getCurrentIndex()

			    // http://stackoverflow.com/questions/2905867/how-to-scroll-to-specific-item-using-jquery

			    var scrollTo = $("div.img#"+index);

			    console.log("index",index, "offset:", originalScroll)
			    $(document).scrollTop(originalScroll )
			    $(window).unbind("resize",setCorrectHeight)

			});


		    pswp.listen('destroy', function(){
			    $("#pswp-container").css('z-index',-10);
			    $(pswpElement).hide();
			    pswpIsOpen = false;
			    console.log("scrolling back again!",originalScroll)
			    $(".right-sticky").attr('id', 'right-sticky')
			    // $(document).scrollTop(originalScroll )
			});

		    pswp.init();
		}

		$(window).bind("resize",function() {if (pswpIsOpen) setCorrectHeight()})

		// sets the container underneath photoswipe to fill the remaining space
	    function setCorrectHeight() {
	    	console.log("setCorrectHeight")
	    	$(".gallery").css({
		    	marginTop: $("#pswp-container").height(),
		    	height:$(window).innerHeight()-$("#pswp-container").height(),
		    	overflowX: 'hidden',
		    	overflowY: 'auto'
		    })
	    }
		// Resize photoswipe div 
		$(function () {
			var isResizing = false;

		    var handle = $('#handle'),
		    	container = $("#pswp-container");

		    handle.on('mousedown', function (e) {
		        isResizing = true;
		        console.log("resizing")
		        e.preventDefault();
			    $(document).on('mousemove', moveResizer); 
			    $(document).on('mouseup', function (e) {
			        // stop resizing
			        isResizing = false;
			        $(document).off('mousemove', moveResizer)
			    });
		    });

		    function moveResizer(e) {
		        // we don't want to do anything if we aren't resizing.
		        if (!isResizing) 
		            return;
		        
		        var offsetBottom = e.clientY + container.offset().top ;
		        console.log("resizing move", e.clientY,  offsetBottom)
		        container.css('height', offsetBottom)
		        setCorrectHeight();
		        if (pswp) pswp.updateSize(true);

		    }
		    
		});
		function first(p){for(var i in p)return i;}
		
		$("#pswp-container").on('wheel', function(e) {
			var delta = e.originalEvent.deltaY;
			delta = Math.min(1,Math.max(-1, Math.round(delta/100)))
			if (pswp) {
				var top_index = imgs.lastIndexOf(imgs.slice(-1)[0]);
				var bottom_index = parseInt(first(imgs));
				var new_index = pswp.getCurrentIndex()+delta;
				if (new_index > top_index) new_index = new_index - top_index + bottom_index
				else if (new_index < bottom_index) new_index = new_index + top_index - bottom_index
				console.log(top_index ,bottom_index ,new_index)
				pswp.goTo(new_index);
			}
			return false;
		});

		function generate_annotation_file() {
			var first = function(elements) {return elements.find(function(element) { return !!element })};

			var curr_evt = null
			var curr_label = null
			var curr_start = null
			var str = "startTime, endTime, annotation\n";
			console.log("STARTING", curr_evt,curr_start, curr_label)

			var last_idx = -100;
			evts.forEach((e, i) => {
				last_idx = Math.max(i, last_idx)
				var label = labels[e];
				// console.log(i, e, label)
				if (curr_evt!== e || label !== curr_label) {
					if (curr_start!==null) {
						var end = img_times[i-1];
						str += curr_start.toISOString() + ',' + end.toISOString() + ',' + curr_label + '\n';
					}
					curr_label = label;
					curr_evt = e;
					curr_start = img_times[i];
					console.log(e,i, label, curr_start.toISOString())
				}
			})
			if (last_idx!==-100) {
				var end = img_times[last_idx];
				str += curr_start.toISOString() + ',' + end.toISOString() + ',' + curr_label + '\n';
			}
			console.log(str)
			return str
		}

		function save_annotation() {
			if (current_schema===null) return console.log("current schema not set (may be mid-load)", current_schema)
			var data = generate_annotation_file();
			return $.post('/participant/'+participant_name+'/save', {data:data, schema:current_schema})

		}

		function read_annotation_file(text) {
			var text = text.split('\n')

			if (text[0]!=="startTime, endTime, annotation") return console.log("first row of csv not valid:", text[0])
			text.splice(0,1);

			var curr_idx = null;
			var evt_idx = 0;
			evts = [];
			labels = {};
			for (var i in img_times) {curr_idx = parseInt(i); break;} // set to first
			text.forEach((line, idx) => {
				var l=line.split(','); // TODO: check for escaped commas
				if (l.length!==3) return // empty line

				 var startDate =  new Date(l[0]);
				 var endDate =  new Date(l[1]);
				 var annotation = l[2]==="undefined" ? undefined : l[2];
				 if (annotation!==undefined) {

				 }
				 labels[evt_idx] = annotation;
				 color = label_to_color[annotation];
				 while(true) {
				 	if (img_times[curr_idx] < startDate) curr_idx++;
				 	else break;
				 }
				 start_idx = curr_idx
				 while(true) {
				 	evts[curr_idx] = evt_idx;

				 	if (img_times[curr_idx] < endDate) curr_idx++;
				 	else break;
				 }
				 end_idx = curr_idx
				 // console.log('->', startDate.toLocaleTimeString(), " - ", endDate.toLocaleTimeString(), "   ", annotation,"   - ", start_idx, end_idx)
				 // console.log('->', img_times[start_idx].toLocaleTimeString(), " - ", img_times[end_idx].toLocaleTimeString(), color)

				 evt_idx++;
			})

			for (var idx in evts) {
				idx = parseInt(idx)
				svg_update(idx)
			 	svg_colorize(idx, label_to_color[labels[evts[idx]]])
			 }


		}
		function load_annotation() {
			$.get('/annotation/'+participant_name+'/annotation_'+current_schema+'',{},(data) => {
				console.log('loaded annotation')
				read_annotation_file(data)
			}).fail(() => {
				console.log('annotation failed to load')
			})
		}
		$("#btn-save").click(()=>{
			console.log("save", this)
			var temp_icon = 'fa-spinner'
			$("#btn-save").find('i').removeClass('fa-floppy-o').addClass(temp_icon)
			save_annotation().then(() => {
				$("#btn-save").find('i').removeClass(temp_icon).addClass('fa-floppy-o')
			})
		})
	</script>

</body>
</html>